<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Examples 课堂练习</title>
</head>

<body>
  <!--   <div>
    遍历节点数
    <p></p>
    <span>
      <strong></strong>
      <b></b>
    </span>
  </div> -->
  <!--   <div>
    第二题
    <strong>
      <span>
        <i></i>
      </span>
    </strong>
  </div> -->

  <div>
    <span></span>
    <p></p>
    <strong></strong>
    <i></i>
    <address></address>
  </div>


  <!--   <div>
    <b>
      第四题 -->
  <!-- 注释 -->
  <!--     </b>
    <strong>
      <span>
        <i></i>
      </span>
    </strong>
    <input type="text" value="测试数据">
  </div> -->
  <script type="text/javascript">
  /*
   * 1. 遍历元素节点树(在原型上编程)
   * 2. 封装函数, 返回元素e的第n层祖先元素节点
   * 3. 封装函数, 返回元素e的第n个兄弟元素节点, n为正, 返回后面的兄弟元素节点。n为负, 返回前面的。n为0, 返回自己
   * 4. 编辑函数, 封装myChildren功能, 解决以前部分浏览器的兼容性问题
   * 5. 自己封装hasChildren()方法, 不可用children属性
   */

  // 2. 封装函数, 返回元素e的第n层祖先元素节点
  /*
     function retParent(elem, n) {
      while(elem && n) {
        elem = elem.parentElement;
        n --;
      }
      return elem;
     }

     var i = document.getElementsByTagName('i')[0];

     // console.log(retParent(i, 2));
     console.log(retParent(i, 10));     // 报错, 容错
  //*/

  // 3. 封装函数, 返回元素e的第n个兄弟
  //*
     // function retSibling(e, n) {
     //  // 不考虑兼容性的问题
     //  while(e && n) {
     //    if(n > 0) {
     //      e = e.nextElementSibing;
     //      n--;
     //    } else {
     //      e = e.previousElementSibing;
     //      n++;
     //    }
     //  }
     //  return e;
     // }

     // var strong = document.getElementsByTagName('strong')[0];
     // console.log(retSibling(strong, 1));

     function retSibling(e, n) {
      // 兼容ie9以下
      while(e && n) {
        if(n > 0) {
          // e = e.nextElementSibing;
          e.nextElementSibing ? e.nextElementSibing : function(){
            // 经典for循环
            for(e = e.nextSibling; e && e.nodeType != 1; e = e.nextSibling);
          }();
          n--;
        } else {

          e.previousElementSibing ? e.previousElementSibing : function(){
            // 经典for循环
            for(e = e.previousSibling; e && e.nodeType != 1; e = e.previousSibling);
          }();
          n++;
        }
      }
      return e;
     }

     var strong = document.getElementsByTagName('strong')[0];
     // console.log(retSibling(strong, 3));   // ncaught TypeError: Cannot read property 'nodeType' of null
     // e && e.nodeType e前面加个e &&就行了
     console.log(retSibling(strong, 3));      // null


  //*/

  // 4. 编辑函数, 封装myChildren功能, 解决以前部分浏览器的兼容性问题
  /*
     Element.prototype.myChildren = function() {
        var child = this.childNodes;
        var len = child.length;
        var arr = [];
        for (var i = 0; i < len; i++) {
          if(child[i].nodeType == 1) {
            arr.push(child[i]);
          }
        }
        return arr;
     };

     var div = document.getElementsByTagName('div')[0];
     console.log(div.myChildren()[2].value)
  //*/

  // 5. 自己封装hasChildren()方法, 不可用children属性
  //*

  //*/
  </script>
</body>

</html>